import { Callout, Steps } from "nextra/components";

# Create your first entity

Make sure you followed the [Getting Started](/getting-started) before starting this tutorial.

Let's dive into creating a full new entity with database, backend and ui.<br />
We will create a **"Project"** entity with the full CRUD (Create Read Update Delete) screens.

## Step 1: Create the Project database schema

<Steps>
### Update the Prisma Database Schema

We will use [Prisma](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model) to add the project entity to our database schema.<br />
Open the `prisma/schema.prisma` file and add a new model called `Project` with the following fields.

```prisma filename="prisma/schema.prisma"
model Project {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  name        String   @unique
  description String?
}
```

Then, run the `pnpm db:push{:bash}` command to update your database.

### Create you first project

We can see what is inside of our database with the `pnpm db:ui{:bash}` command.<br />
You should see your `Project` model and be able to create a new project like the following.

![Step 01](/images/tutorials/create-your-first-entity/db-ui-01.png)<br />
![Step 02](/images/tutorials/create-your-first-entity/db-ui-02.png)<br />
![Step 03](/images/tutorials/create-your-first-entity/db-ui-03.png)<br />

### Create database seeds

For easy development and better Developer eXperience (DX), we will create a new seed for our new `Project` model.<br />
This will allows every new developer to start with some projects instead of an empty database.

Create an new file `project.ts` in the `prisma/seed/models` folder with a `createProjects` function.

```ts filename="prisma/seed/models/project.ts" showLineNumbers
export async function createProjects() {
  // ...
}
```

Add a console.log for better DX.

```ts {2} filename="prisma/seed/models/project.ts" showLineNumbers
export async function createProjects() {
  console.log(`â³ Seeding projects`);
  // ...
}
```

Check if the project exist to make the seed idempotent.

```ts {1, 6-8} filename="prisma/seed/models/project.ts" showLineNumbers
import { prisma } from "prisma/seed/utils";

export async function createProjects() {
  console.log(`â³ Seeding projects`);

  if (!(await prisma.project.findUnique({ where: { name: "My Project" } }))) {
    // ...
  }
}
```

Create the project with prisma.

```ts {7-12} filename="prisma/seed/models/project.ts" showLineNumbers
import { prisma } from "prisma/seed/utils";

export async function createProjects() {
  console.log(`â³ Seeding projects`);

  if (!(await prisma.project.findUnique({ where: { name: "My Project" } }))) {
    await prisma.project.create({
      data: {
        name: "My Project",
        description: "This is a project created with the seed command",
      },
    });
  }
}
```

Now, import the function into the `prisma/seed/index.ts` file.

```ts {3,9} filename="prisma/seed/index.ts"
import { createRepositories } from "prisma/seed/models/repository";
import { createUsers } from "prisma/seed/models/user";
import { createProjects } from "prisma/seed/models/project";
import { prisma } from "prisma/seed/utils";

async function main() {
  await createRepositories();
  await createUsers();
  await createProjects();
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(() => {
    prisma.$disconnect();
  });
```

Finally, run the seed command.

```bash
pnpm db:seed
```

You can check that the project is created by running the `pnpm db:ui{:bash}` command again.

![Seed result](/images/tutorials/create-your-first-entity/db-seed-result.png)<br />

</Steps>

---

## Step 2: Create the backend router

<Steps>
### Create the tRPC routers

Create a `projects.ts` file in the `src/server/routers` folder and create an empty tRPC router with the following code.

```ts filename="src/server/routers/projects.ts" showLineNumbers
import { createTRPCRouter } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  //...
});
```

Then, import this router in the `src/server/router.ts` file.

```ts {4,12} filename="src/server/router.ts"
// ...
import { accountRouter } from "@/server/routers/account";
import { authRouter } from "@/server/routers/auth";
import { projectsRouter } from "@/server/routers/projects";
import { repositoriesRouter } from "@/server/routers/repositories";
import { usersRouter } from "@/server/routers/users";

// ...
export const appRouter = createTRPCRouter({
  account: accountRouter,
  auth: authRouter,
  projects: projectsRouter,
  repositories: repositoriesRouter,
  users: usersRouter,
});

// ...
```

### Add the first query to list the projects

We will create a query to get all the projects from the database.<br />
In the projects router file (`src/server/routers/projects.ts`), create a `getAll` key for our query.

```ts {4} filename="src/server/routers/projects.ts" showLineNumbers
import { createTRPCRouter } from '@/server/config/trpc';

export const projectsRouter = createTRPCRouter({
  getAll: //...
});
```

We need this query to be protected and be accessible only by the admin users. So we will use the `protectedProcedure`.

```ts {1,4} filename="src/server/routers/projects.ts" showLineNumbers
import { createTRPCRouter, protectedProcedure } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  getAll: protectedProcedure({ authorizations: ["ADMIN"] }), //...
});
```

Then we need to create the `input` and the `output` of our query. For now, the input will be void and the output will only return an array of projects with `id` and `name` properties.

```ts {1,7-16} filename="src/server/routers/projects.ts" showLineNumbers
import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  getAll: protectedProcedure({ authorizations: ["ADMIN"] })
    .input(z.void())
    .output(
      z.array(
        z.object({
          id: z.string().cuid(),
          name: z.string(),
          description: z.string().nullish(),
        })
      )
    ), //...
});
```

Will will add some `meta` to auto generate the REST api based on the tRPC api.

<Callout type="info">
  This step is optional, if you don't plan to support and maintain the REST api,
  you can skip this step.
</Callout>

```ts {7-14} filename="src/server/routers/projects.ts" showLineNumbers
import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  getAll: protectedProcedure({ authorizations: ["ADMIN"] })
    .meta({
      openapi: {
        method: "GET",
        path: "/projects",
        protect: true,
        tags: ["projects"],
      },
    })
    .input(z.void())
    .output(
      z.array(
        z.object({
          id: z.string().cuid(),
          name: z.string(),
          description: z.string().nullish(),
        })
      )
    ), //...
});
```

And now, let create the query with the projects.

```ts {25-28} filename="src/server/routers/projects.ts" showLineNumbers
import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  getAll: protectedProcedure({ authorizations: ["ADMIN"] })
    .meta({
      openapi: {
        method: "GET",
        path: "/projects",
        protect: true,
        tags: ["projects"],
      },
    })
    .input(z.void())
    .output(
      z.array(
        z.object({
          id: z.string().cuid(),
          name: z.string(),
          description: z.string().nullish(),
        })
      )
    )
    .query(async ({ ctx }) => {
      const projects = await ctx.db.project.findMany();
      return projects;
    }),
});
```

### Add load more capability

We will allows the query to be paginated with a load more strategy.

First, let's update our input to accept a `limit` and a `cursor` params.

```ts {16-21} filename="src/server/routers/projects.ts" showLineNumbers
import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  getAll: protectedProcedure({ authorizations: ["ADMIN"] })
    .meta({
      openapi: {
        method: "GET",
        path: "/projects",
        protect: true,
        tags: ["projects"],
      },
    })
    .input(
      z
        .object({
          cursor: z.string().cuid().nullish(),
          limit: z.number().min(1).max(100).default(20),
        })
        .default({})
    )
    .output(
      z.array(
        z.object({
          id: z.string().cuid(),
          name: z.string(),
          description: z.string().nullish(),
        })
      )
    )
    .query(async ({ ctx }) => {
      const projects = await ctx.db.project.findMany();
      return projects;
    }),
});
```

Then we will need to update our prisma query.

```ts {32-39} filename="src/server/routers/projects.ts" showLineNumbers
import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  getAll: protectedProcedure({ authorizations: ["ADMIN"] })
    .meta({
      openapi: {
        method: "GET",
        path: "/projects",
        protect: true,
        tags: ["projects"],
      },
    })
    .input(
      z
        .object({
          cursor: z.string().cuid().nullish(),
          limit: z.number().min(1).max(100).default(20),
        })
        .default({})
    )
    .output(
      z.array(
        z.object({
          id: z.string().cuid(),
          name: z.string(),
          description: z.string().nullish(),
        })
      )
    )
    .query(async ({ ctx, input }) => {
      const projects = await ctx.db.project.findMany({
        // Get an extra item at the end which we'll use as next cursor
        take: input.limit + 1,
        cursor: input.cursor ? { id: input.cursor } : undefined,
      });
      return projects;
    }),
});
```

Now, we need to update our output to send not only the projects but also the `nextCursor`.

```ts {23-34,42-48} filename="src/server/routers/projects.ts" showLineNumbers
import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  getAll: protectedProcedure({ authorizations: ["ADMIN"] })
    .meta({
      openapi: {
        method: "GET",
        path: "/projects",
        protect: true,
        tags: ["projects"],
      },
    })
    .input(
      z
        .object({
          cursor: z.string().cuid().nullish(),
          limit: z.number().min(1).max(100).default(20),
        })
        .default({})
    )
    .output(
      z.object({
        items: z.array(
          z.object({
            id: z.string().cuid(),
            name: z.string(),
            description: z.string().nullish(),
          })
        ),
        nextCursor: z.string().cuid().nullish(),
      })
    )
    .query(async ({ ctx, input }) => {
      const projects = await ctx.db.project.findMany({
        // Get an extra item at the end which we'll use as next cursor
        take: input.limit + 1,
        cursor: input.cursor ? { id: input.cursor } : undefined,
      });

      let nextCursor: typeof input.cursor | undefined = undefined;
      if (projects.length > input.limit) {
        const nextProject = projects.pop();
        nextCursor = nextProject?.id;
      }

      return { items: projects, nextCursor };
    }),
});
```

We will now add the total of projects in the data in the output to let the UI now how many projects are available even if now the UI will not request all projects at once.

```ts {33,37-38,43-44,52} filename="src/server/routers/projects.ts" showLineNumbers
import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  getAll: protectedProcedure({ authorizations: ["ADMIN"] })
    .meta({
      openapi: {
        method: "GET",
        path: "/projects",
        protect: true,
        tags: ["projects"],
      },
    })
    .input(
      z
        .object({
          cursor: z.string().cuid().nullish(),
          limit: z.number().min(1).max(100).default(20),
        })
        .default({})
    )
    .output(
      z.object({
        items: z.array(
          z.object({
            id: z.string().cuid(),
            name: z.string(),
            description: z.string().nullish(),
          })
        ),
        nextCursor: z.string().cuid().nullish(),
        total: z.number(),
      })
    )
    .query(async ({ ctx, input }) => {
      const [total, projects] = await ctx.db.$transaction([
        ctx.db.project.count(),
        ctx.db.project.findMany({
          // Get an extra item at the end which we'll use as next cursor
          take: input.limit + 1,
          cursor: input.cursor ? { id: input.cursor } : undefined,
        }),
      ]);

      let nextCursor: typeof input.cursor | undefined = undefined;
      if (projects.length > input.limit) {
        const nextProject = projects.pop();
        nextCursor = nextProject?.id;
      }

      return { items: projects, nextCursor, total };
    }),
});
```

### Add search capability

Let's add the possibility to search a project by name. We are adding a `searchTerm` in the input and add a `where` clause.
We need to put this `where` on both prisma requests, so we can create a constant with the help of the `Prisma.ProjectWhereInput` generated types.

```ts {1, 21, 39-44, 47, 52} filename="src/server/routers/projects.ts" showLineNumbers
import { Prisma } from "@prisma/client";
import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  getAll: protectedProcedure({ authorizations: ["ADMIN"] })
    .meta({
      openapi: {
        method: "GET",
        path: "/projects",
        protect: true,
        tags: ["projects"],
      },
    })
    .input(
      z
        .object({
          cursor: z.string().cuid().nullish(),
          limit: z.number().min(1).max(100).default(20),
          searchTerm: z.string().optional(),
        })
        .default({})
    )
    .output(
      z.object({
        items: z.array(
          z.object({
            id: z.string().cuid(),
            name: z.string(),
            description: z.string().nullish(),
          })
        ),
        nextCursor: z.string().cuid().nullish(),
        total: z.number(),
      })
    )
    .query(async ({ ctx, input }) => {
      const where = {
        name: {
          contains: input.searchTerm,
          mode: "insensitive",
        },
      } satisfies Prisma.ProjectWhereInput;

      const [total, projects] = await ctx.db.$transaction([
        ctx.db.project.count({ where }),
        ctx.db.project.findMany({
          // Get an extra item at the end which we'll use as next cursor
          take: input.limit + 1,
          cursor: input.cursor ? { id: input.cursor } : undefined,
          where,
        }),
      ]);

      let nextCursor: typeof input.cursor | undefined = undefined;
      if (projects.length > input.limit) {
        const nextProject = projects.pop();
        nextCursor = nextProject?.id;
      }

      return { items: projects, nextCursor, total };
    }),
});
```

</Steps>

---

## Step 3: Create the feature folder

<Steps>
### Create the feature folder

To put the UI and shared code, let's create a `projects` folder in the `src/features` folder.
It's in this folder that we will put all the UI of the projects feature and also the shared code between server and UI.

### Extract project zod schema

First to we will extract the zod schema for the project from the tRPC router and put it into a `schemas.ts` file in the `src/features/projects` folder.

Let's create the `src/features/projects/schemas.ts` file with the zod schema for one project.

```ts filename="src/features/projects/schemas.ts" showLineNumbers
import { z } from "zod";

export const zProject = () =>
  z.object({
    id: z.string().cuid(),
    name: z.string(),
    description: z.string().nullish(),
  });
```

Let's create the type from this schema.

```ts {3} filename="src/features/projects/schemas.ts" showLineNumbers
import { z } from "zod";

export type Project = z.infer<ReturnType<typeof zProject>>;
export const zProject = () =>
  z.object({
    id: z.string().cuid(),
    name: z.string(),
    description: z.string().nullish(),
  });
```

Use this schema in the tRPC router in the `src/server/routers/projects.ts` file.

```ts {4, 13} filename="src/server/routers/projects.ts" showLineNumbers
import { Prisma } from "@prisma/client";
import { z } from "zod";

import { zProject } from "@/features/projects/schemas";
import { createTRPCRouter, protectedProcedure } from "@/server/config/trpc";

export const projectsRouter = createTRPCRouter({
  getAll: protectedProcedure({ authorizations: ["ADMIN"] })
    .meta(/* ... */)
    .input(/* ... */)
    .output(
      z.object({
        items: z.array(zProject()),
        nextCursor: z.string().cuid().nullish(),
      })
    )
    .query(/* ... */),
});
```

</Steps>

---

## Step 4: List all the projects in the UI

<Steps>
### Create the page

Create the file `PageAdminProjects.tsx` in the `src/features/projects` folder with the following content.

```tsx filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
import { Heading } from "@chakra-ui/react";

import {
  AdminLayoutPage,
  AdminLayoutPageContent,
} from "@/features/admin/AdminLayoutPage";

export default function PageAdminProjects() {
  return (
    <AdminLayoutPage>
      <AdminLayoutPageContent>
        <Heading flex="none" size="md">
          Projects
        </Heading>
        ...
      </AdminLayoutPageContent>
    </AdminLayoutPage>
  );
}
```

### Create the NextJS route

To expose the page component, we need to create the route in the NextJS app router.<br />
Create a `page.tsx` file in the a new `projects` folder in `src/app/admin/(authenticated)` folder.

```tsx filename="src/app/admin/(authenticated)/projects/page.tsx" showLineNumbers
"use client";

import PageAdminProjects from "@/features/projects/PageAdminProjects";

export default function Page() {
  return <PageAdminProjects />;
}
```

You can run the `pnpm dev` and visit the [localhost:3000/admin/projects](http://localhost:3000/admin/projects) url to see the result. (You might need to login first).

### Display the data

First, let's get the data with tRPC and the `@tanstack/react-query` integration in the `PageAdminProjects.tsx` file.

```tsx {7,10} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
import { Heading } from "@chakra-ui/react";

import {
  AdminLayoutPage,
  AdminLayoutPageContent,
} from "@/features/admin/AdminLayoutPage";
import { trpc } from '@/lib/trpc/client';

export default function PageAdminProjects() {
  const projects = trpc.projects.getAll.useQuery();

  return (
    /* ... */
  );
}
```

Then, use the DataList component to display the data.

```tsx {1, 3-8, 21, 25-39} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
import { Heading, Stack } from "@chakra-ui/react";

import {
  DataList,
  DataListCell,
  DataListRow,
  DataListText,
} from "@/components/DataList";
import {
  AdminLayoutPage,
  AdminLayoutPageContent,
} from "@/features/admin/AdminLayoutPage";
import { trpc } from "@/lib/trpc/client";

export default function PageAdminProjects() {
  const projects = trpc.projects.getAll.useQuery();

  return (
    <AdminLayoutPage>
      <AdminLayoutPageContent>
        <Stack spacing={4}>
          <Heading flex="none" size="md">
            Projects
          </Heading>
          <DataList>
            {projects.data?.items.map((project) => (
              <DataListRow key={project.id}>
                <DataListCell>
                  <DataListText fontWeight="bold">{project.name}</DataListText>
                </DataListCell>
                <DataListCell>
                  <DataListText color="text-dimmed">
                    {project.description}
                  </DataListText>
                </DataListCell>
              </DataListRow>
            ))}
          </DataList>
        </Stack>
      </AdminLayoutPageContent>
    </AdminLayoutPage>
  );
}
```

You should have this result on [localhost:3000/admin/projects](http://localhost:3000/admin/projects) ðŸ‘‡

![Display DataList](/images/tutorials/create-your-first-entity/display-datalist.png)

### Handle loading, empty and error state

```tsx {6-8, 29-35} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
import { Heading, Stack } from "@chakra-ui/react";

import {
  DataList,
  DataListCell,
  DataListEmptyState,
  DataListErrorState,
  DataListLoadingState,
  DataListRow,
  DataListText,
} from "@/components/DataList";
import {
  AdminLayoutPage,
  AdminLayoutPageContent,
} from "@/features/admin/AdminLayoutPage";
import { trpc } from "@/lib/trpc/client";

export default function PageAdminProjects() {
  const projects = trpc.projects.getAll.useQuery();

  return (
    <AdminLayoutPage>
      <AdminLayoutPageContent>
        <Stack spacing={4}>
          <Heading flex="none" size="md">
            Projects
          </Heading>
          <DataList>
            {projects.isLoading && <DataListLoadingState />}
            {projects.isError && (
              <DataListErrorState retry={() => projects.refetch()} />
            )}
            {projects.isSuccess && !projects.data.items.length && (
              <DataListEmptyState />
            )}
            {projects.data?.items.map((project) => (
              <DataListRow key={project.id}>
                <DataListCell>
                  <DataListText fontWeight="bold">{project.name}</DataListText>
                </DataListCell>
                <DataListCell>
                  <DataListText color="text-dimmed">
                    {project.description}
                  </DataListText>
                </DataListCell>
              </DataListRow>
            ))}
          </DataList>
        </Stack>
      </AdminLayoutPageContent>
    </AdminLayoutPage>
  );
}
```

### Add load more

First, we need to use `useInfiniteQuery` instead of `useQuery` and implement the getNextPageParam logic.

```tsx {4-9} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
/* ... */

export default function PageAdminProjects() {
  const projects = trpc.projects.getAll.useInfiniteQuery(
    {},
    {
      getNextPageParam: (lastPage) => lastPage.nextCursor,
    }
  );

  return (
    /* ... */
  );
}
```

Now, we need to update how we display the data.

```tsx {18-19, 22-24} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
/* ... */

export default function PageAdminProjects() {
  /* ... */

  return (
    <AdminLayoutPage>
      <AdminLayoutPageContent>
        <Stack spacing={4}>
          <Heading flex="none" size="md">
            Projects
          </Heading>
          <DataList>
            {projects.isLoading && <DataListLoadingState />}
            {projects.isError && (
              <DataListErrorState retry={() => projects.refetch()} />
            )}
            {projects.isSuccess &&
              !projects.data.pages.flatMap((p) => p.items).length && (
                <DataListEmptyState />
              )}
            {projects.data?.pages
              .flatMap((p) => p.items)
              .map((project) => (
                <DataListRow key={project.id}>
                  <DataListCell>
                    <DataListText fontWeight="bold">
                      {project.name}
                    </DataListText>
                  </DataListCell>
                  <DataListCell>
                    <DataListText color="text-dimmed">
                      {project.description}
                    </DataListText>
                  </DataListCell>
                </DataListRow>
              ))}
          </DataList>
        </Stack>
      </AdminLayoutPageContent>
    </AdminLayoutPage>
  );
}
```

And now, let's add the load more button.

```tsx {1, 40-53} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
import { Button, Heading, Stack } from "@chakra-ui/react";

/* ... */

export default function PageAdminProjects() {
  /* ... */

  return (
    <AdminLayoutPage>
      <AdminLayoutPageContent>
        <Stack spacing={4}>
          <Heading flex="none" size="md">
            Projects
          </Heading>
          <DataList>
            {projects.isLoading && <DataListLoadingState />}
            {projects.isError && (
              <DataListErrorState retry={() => projects.refetch()} />
            )}
            {projects.isSuccess &&
              !projects.data.pages.flatMap((p) => p.items).length && (
                <DataListEmptyState />
              )}
            {projects.data?.pages
              .flatMap((p) => p.items)
              .map((project) => (
                <DataListRow key={project.id}>
                  <DataListCell>
                    <DataListText fontWeight="bold">
                      {project.name}
                    </DataListText>
                  </DataListCell>
                  <DataListCell>
                    <DataListText color="text-dimmed">
                      {project.description}
                    </DataListText>
                  </DataListCell>
                </DataListRow>
              ))}
            {projects.isSuccess && (
              <DataListRow mt="auto">
                <DataListCell>
                  <Button
                    size="sm"
                    onClick={() => projects.fetchNextPage()}
                    isLoading={projects.isFetchingNextPage}
                    isDisabled={!projects.hasNextPage}
                  >
                    Load more
                  </Button>
                </DataListCell>
              </DataListRow>
            )}
          </DataList>
        </Stack>
      </AdminLayoutPageContent>
    </AdminLayoutPage>
  );
}
```

Want to test with only 2 projects? Add `limit: 1` to the `useInfiniteQuery` and you should be able to see the first project and click on "Load more" to display the second projecT.

```tsx {2} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
const projects = trpc.projects.getAll.useInfiniteQuery(
  { limit: 1 },
  {
    getNextPageParam: (lastPage) => lastPage.nextCursor,
  }
);
```

Revert this last change to continue.

### Add search

First, let's add the `SearchInput` component in the UI.

```tsx {1, 12-16, 20-21} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
import { SearchInput } from "@/components/SearchInput";

/* ... */

export default function PageAdminProjects() {
  /* ... */

  return (
    <AdminLayoutPage>
      <AdminLayoutPageContent>
        <Stack spacing={4}>
          <Flex
            flexDirection={{ base: "column", md: "row" }}
            alignItems={{ base: "start", md: "center" }}
            gap={4}
          >
            <Heading flex="none" size="md">
              Projects
            </Heading>
            <SearchInput size="sm" maxW={{ base: "none", md: "20rem" }} />
          </Flex>
          <DataList>{/* ... */}</DataList>
        </Stack>
      </AdminLayoutPageContent>
    </AdminLayoutPage>
  );
}
```

Then connect the `SearchInput` value to the `useInfiniteQuery` via a search param (`s`) in the url.

```tsx {1-2, 7-9, 12-14, 33-34} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
import { useSearchParams } from "next/navigation";
import { useSearchParamsUpdater } from "@/hooks/useSearchParamsUpdater";

/* ... */

export default function PageAdminProjects() {
  const searchParams = useSearchParams();
  const searchParamsUpdater = useSearchParamsUpdater();
  const searchTerm = searchParams.get("s") ?? "";

  const projects = trpc.projects.getAll.useInfiniteQuery(
    {
      searchTerm,
    },
    {
      getNextPageParam: (lastPage) => lastPage.nextCursor,
    }
  );

  return (
    <AdminLayoutPage>
      <AdminLayoutPageContent>
        <Stack spacing={4}>
          <Flex
            flexDirection={{ base: "column", md: "row" }}
            alignItems={{ base: "start", md: "center" }}
            gap={4}
          >
            <Heading flex="none" size="md">
              Projects
            </Heading>
            <SearchInput
              value={searchTerm}
              onChange={(value) => searchParamsUpdater({ s: value || null })}
              size="sm"
              maxW={{ base: "none", md: "20rem" }}
            />
          </Flex>
          <DataList>{/* ... */}</DataList>
        </Stack>
      </AdminLayoutPageContent>
    </AdminLayoutPage>
  );
}
```

Let's just add the search term to the existing `<DataListEmptyState />` for a better UX.

```tsx {2} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
/* ... */
<DataListEmptyState searchTerm={searchTerm} />
/* ... */
```

### Result

You can view the projects at [localhost:3000/admin/projects](http://localhost:3000/admin/projects), the page should looks like this.

![Projects listing](/images/tutorials/create-your-first-entity/projects-list.png)

And the final code of `PageAdminProjects.tsx` file should look like this.

```tsx filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
import { Button, Flex, Heading, Stack } from "@chakra-ui/react";
import { useSearchParams } from "next/navigation";

import {
  DataList,
  DataListCell,
  DataListEmptyState,
  DataListErrorState,
  DataListLoadingState,
  DataListRow,
  DataListText,
} from "@/components/DataList";
import { SearchInput } from "@/components/SearchInput";
import {
  AdminLayoutPage,
  AdminLayoutPageContent,
} from "@/features/admin/AdminLayoutPage";
import { useSearchParamsUpdater } from "@/hooks/useSearchParamsUpdater";
import { trpc } from "@/lib/trpc/client";

export default function PageAdminProjects() {
  const searchParams = useSearchParams();
  const searchParamsUpdater = useSearchParamsUpdater();
  const searchTerm = searchParams.get("s") ?? "";

  const projects = trpc.projects.getAll.useInfiniteQuery(
    {
      searchTerm,
    },
    {
      getNextPageParam: (lastPage) => lastPage.nextCursor,
    }
  );

  return (
    <AdminLayoutPage>
      <AdminLayoutPageContent>
        <Stack spacing={4}>
          <Flex
            flexDirection={{ base: "column", md: "row" }}
            alignItems={{ base: "start", md: "center" }}
            gap={4}
          >
            <Heading flex="none" size="md">
              Projects
            </Heading>
            <SearchInput
              value={searchTerm}
              onChange={(value) => searchParamsUpdater({ s: value || null })}
              size="sm"
              maxW={{ base: "none", md: "20rem" }}
            />
          </Flex>
          <DataList>
            {projects.isLoading && <DataListLoadingState />}
            {projects.isError && (
              <DataListErrorState retry={() => projects.refetch()} />
            )}
            {projects.isSuccess &&
              !projects.data.pages.flatMap((p) => p.items).length && (
                <DataListEmptyState searchTerm={searchTerm} />
              )}
            {projects.data?.pages
              .flatMap((p) => p.items)
              .map((project) => (
                <DataListRow key={project.id}>
                  <DataListCell>
                    <DataListText fontWeight="bold">
                      {project.name}
                    </DataListText>
                  </DataListCell>
                  <DataListCell>
                    <DataListText color="text-dimmed">
                      {project.description}
                    </DataListText>
                  </DataListCell>
                </DataListRow>
              ))}
            {projects.isSuccess && (
              <DataListRow mt="auto">
                <DataListCell>
                  <Button
                    size="sm"
                    onClick={() => projects.fetchNextPage()}
                    isLoading={projects.isFetchingNextPage}
                    isDisabled={!projects.hasNextPage}
                  >
                    Load more
                  </Button>
                </DataListCell>
              </DataListRow>
            )}
          </DataList>
        </Stack>
      </AdminLayoutPageContent>
    </AdminLayoutPage>
  );
}
```

</Steps>

---

## Step 5: Allows to create a project

<Steps>

### Create the tRPC mutation

In the tRPC router we will add the mutation, add the `create` key in the `src/server/routers/projects.ts` file with `meta`, `input` and `output` like we did with the `getAll` query.

```ts {6-21} filename="src/server/routers/projects.ts" showLineNumbers
/* ... */

export const projectsRouter = createTRPCRouter({
  getAll: /* ... */

  create: protectedProcedure({ authorizations: ['ADMIN'] })
    .meta({
      openapi: {
        method: 'POST',
        path: '/projects',
        protect: true,
        tags: ['projects'],
      },
    })
    .input(
      zProject().pick({
        name: true,
        description: true,
      })
    )
    .output(zProject())
});
```

Then, let's add the logic for the mutation.

```ts {1, 23-34} filename="src/server/routers/projects.ts" showLineNumbers
import { ExtendedTRPCError } from '@/server/config/errors';
/* ... */

export const projectsRouter = createTRPCRouter({
  getAll: /* ... */

  create: protectedProcedure({ authorizations: ['ADMIN'] })
    .meta({
      openapi: {
        method: 'POST',
        path: '/projects',
        protect: true,
        tags: ['projects'],
      },
    })
    .input(
      zProject().pick({
        name: true,
        description: true,
      })
    )
    .output(zProject())
    .mutation(async ({ ctx, input }) => {
      try {
        ctx.logger.info('Creating project');
        return await ctx.db.project.create({
          data: input,
        });
      } catch (e) {
        throw new ExtendedTRPCError({
          cause: e,
        });
      }
    }),
});
```

### Create the page

Create the file `PageAdminProjectCreate.tsx` in the `src/features/projects` folder with the following content.

```tsx filename="src/features/projects/PageAdminProjectCreate.tsx" showLineNumbers
import { Button, Heading } from "@chakra-ui/react";

import { AdminBackButton } from "@/features/admin/AdminBackButton";
import { AdminCancelButton } from "@/features/admin/AdminCancelButton";
import {
  AdminLayoutPage,
  AdminLayoutPageContent,
  AdminLayoutPageTopBar,
} from "@/features/admin/AdminLayoutPage";

export default function PageAdminProjectCreate() {
  return (
    <AdminLayoutPage containerMaxWidth="container.md" showNavBar={false}>
      <AdminLayoutPageTopBar
        leftActions={<AdminBackButton />}
        rightActions={
          <>
            <AdminCancelButton />
            <Button type="submit" variant="@primary">
              Create
            </Button>
          </>
        }
      >
        <Heading size="sm">New Project</Heading>
      </AdminLayoutPageTopBar>
      <AdminLayoutPageContent>...</AdminLayoutPageContent>
    </AdminLayoutPage>
  );
}
```

### Create the NextJS route

To expose the page component, we need to create the route in the NextJS app router.<br />
Create a `page.tsx` file in the a new `create` folder in `src/app/admin/(authenticated)/projects` folder.

```tsx filename="src/app/admin/(authenticated)/projects/create/page.tsx" showLineNumbers
"use client";

import PageAdminProjectCreate from "@/features/projects/PageAdminProjectCreate";

export default function Page() {
  return <PageAdminProjectCreate />;
}
```

You can run the `pnpm dev` and visit the [localhost:3000/admin/projects/create](http://localhost:3000/admin/projects/create) url to see the result. (You might need to login first).

### Create the form

Let's create the form fields by creating a `ProjectForm` component.
Create the `ProjectForm.tsx` in the `src/features/projects` folder and use the `FieldInput` and `FieldTextarea` like the following.

```tsx filename="src/features/projects/ProjectForm.tsx" showLineNumbers
import { Stack } from "@chakra-ui/react";

import { FieldInput } from "@/components/FieldInput";
import { FieldTextarea } from "@/components/FieldTextarea";

export type ProjectFormFields = {
  name: string;
  description?: string | null;
};

export const ProjectForm = () => {
  return (
    <Stack spacing={4}>
      <FieldInput name="name" label="Name" required="Name is required" />
      <FieldTextarea
        name="description"
        label="Description"
        textareaProps={{ rows: 6 }}
      />
    </Stack>
  );
};
```

### Use the form

Now, let's setup Formiz and use this `ProjectForm` in the `PageAdminProjectCreate.tsx` file.

```tsx {2, 11-14, 17, 20, 36, 39} filename="src/features/projects/PageAdminProjectCreate.tsx" showLineNumbers
import { Button, Heading } from "@chakra-ui/react";
import { Formiz, useForm } from "@formiz/core";

import { AdminBackButton } from "@/features/admin/AdminBackButton";
import { AdminCancelButton } from "@/features/admin/AdminCancelButton";
import {
  AdminLayoutPage,
  AdminLayoutPageContent,
  AdminLayoutPageTopBar,
} from "@/features/admin/AdminLayoutPage";
import {
  ProjectForm,
  ProjectFormFields,
} from "@/features/projects/ProjectForm";

export default function PageAdminProjectCreate() {
  const form = useForm<ProjectFormFields>();

  return (
    <Formiz connect={form} autoForm>
      <AdminLayoutPage containerMaxWidth="container.md" showNavBar={false}>
        <AdminLayoutPageTopBar
          leftActions={<AdminBackButton />}
          rightActions={
            <>
              <AdminCancelButton />
              <Button type="submit" variant="@primary">
                Create
              </Button>
            </>
          }
        >
          <Heading size="sm">New Project</Heading>
        </AdminLayoutPageTopBar>
        <AdminLayoutPageContent>
          <ProjectForm />
        </AdminLayoutPageContent>
      </AdminLayoutPage>
    </Formiz>
  );
}
```

### Submit the form

When the form is submitted and valid, we can submit the mutation to the server.

```tsx {1, 5, 7-11} filename="src/features/projects/PageAdminProjectCreate.tsx" showLineNumbers
import { trpc } from '@/lib/trpc/client';
/* ... */

export default function PageAdminProjectCreate() {
  const createProject = trpc.projects.create.useMutation();

  const form = useForm<ProjectFormFields>({
    onValidSubmit: (values) => {
      createProject.mutate(values);
    },
  });

  return (
    /* ... */
  );
}
```

And now, we need to invalidate the project list query and redirect the user when the mutation has succeeded.

<Callout type="warning">
  **`useRouter` is imported from `next/navigation`** and not `next/router`
</Callout>

```tsx {1, 5-6, 8-13} filename="src/features/projects/PageAdminProjectCreate.tsx" showLineNumbers
import { useRouter } from 'next/navigation';
/* ... */

export default function PageAdminProjectCreate() {
  const trpcUtils = trpc.useUtils();
  const router = useRouter();

  const createProject = trpc.projects.create.useMutation({
    onSuccess: async () => {
      await trpcUtils.projects.getAll.invalidate();
      router.back();
    },
  });

  const form = /* ... */

  return (
    /* ... */
  );
}
```

### Enhance UX

Let's improve the UX of the form.

```tsx {1-2, 10-11, 16-18, 21-29, 45-46} filename="src/features/projects/PageAdminProjectCreate.tsx" showLineNumbers
import { useToastError, useToastSuccess } from "@/components/Toast";
import { isErrorDatabaseConflict } from "@/lib/trpc/errors";

/* ... */

export default function PageAdminProjectCreate() {
  const trpcUtils = trpc.useUtils();
  const router = useRouter();

  const toastError = useToastError();
  const toastSuccess = useToastSuccess();

  const createProject = trpc.projects.create.useMutation({
    onSuccess: async () => {
      await trpcUtils.projects.getAll.invalidate();
      toastSuccess({
        title: "Project created with success",
      });
      router.back();
    },
    onError: (error) => {
      if (isErrorDatabaseConflict(error, "name")) {
        form.setErrors({ name: "Name already used" });
        return;
      }
      toastError({
        title: "Failed to create the project",
      });
    },
  });

  const form = /* ... */;

  return (
    <Formiz connect={form} autoForm>
      <AdminLayoutPage containerMaxWidth="container.md" showNavBar={false}>
        <AdminLayoutPageTopBar
          leftActions={<AdminBackButton />}
          rightActions={
            <>
              <AdminCancelButton />
              <Button
                type="submit"
                variant="@primary"
                isLoading={createProject.isLoading || createProject.isSuccess}
                isDisabled={!form.isValid && form.isSubmitted}
              >
                Create
              </Button>
            </>
          }
        >
          <Heading size="sm">New Project</Heading>
        </AdminLayoutPageTopBar>
        <AdminLayoutPageContent>
          <ProjectForm />
        </AdminLayoutPageContent>
      </AdminLayoutPage>
    </Formiz>
  );
}
```

### Add the create button

Now, in the `PageAdminProjects.tsx` file, let's add the create button.

```tsx {1-5, 15, 20, 32-41} filename="src/features/projects/PageAdminProjects.tsx" showLineNumbers
import { Button, Flex, HStack, Heading, Stack } from "@chakra-ui/react";
import Link from "next/link";
import { LuPlus } from "react-icons/lu";
import { ResponsiveIconButton } from "@/components/ResponsiveIconButton";
import { ADMIN_PATH } from "@/features/admin/constants";
/* ... */

export default function PageAdminProjects() {
  /* ... */

  return (
    <AdminLayoutPage>
      <AdminLayoutPageContent>
        <Stack spacing={4}>
          <HStack spacing={4} alignItems={{ base: "end", md: "center" }}>
            <Flex
              flexDirection={{ base: "column", md: "row" }}
              alignItems={{ base: "start", md: "center" }}
              gap={4}
              flex={1}
            >
              <Heading flex="none" size="md">
                Projects
              </Heading>
              <SearchInput
                value={searchTerm}
                onChange={(value) => searchParamsUpdater({ s: value || null })}
                size="sm"
                maxW={{ base: "none", md: "20rem" }}
              />
            </Flex>
            <ResponsiveIconButton
              as={Link}
              href={`${ADMIN_PATH}/projects/create`}
              variant="@primary"
              size="sm"
              icon={<LuPlus />}
            >
              Create Project
            </ResponsiveIconButton>
          </HStack>
          <DataList>{/* ... */}</DataList>
        </Stack>
      </AdminLayoutPageContent>
    </AdminLayoutPage>
  );
}
```

### Result

You can test the form at [localhost:3000/admin/projects/create](http://localhost:3000/admin/projects/create), the page hould looks like this.

![Project create form](/images/tutorials/create-your-first-entity/project-create.png)

And the final code of `PageAdminProjectCreate.tsx` file should look like this.

```tsx filename="src/features/projects/PageAdminProjectCreate.tsx" showLineNumbers
import { Button, Heading } from "@chakra-ui/react";
import { Formiz, useForm } from "@formiz/core";
import { useRouter } from "next/navigation";

import { useToastError, useToastSuccess } from "@/components/Toast";
import { AdminBackButton } from "@/features/admin/AdminBackButton";
import { AdminCancelButton } from "@/features/admin/AdminCancelButton";
import {
  AdminLayoutPage,
  AdminLayoutPageContent,
  AdminLayoutPageTopBar,
} from "@/features/admin/AdminLayoutPage";
import {
  ProjectForm,
  ProjectFormFields,
} from "@/features/projects/ProjectForm";
import { trpc } from "@/lib/trpc/client";
import { isErrorDatabaseConflict } from "@/lib/trpc/errors";

export default function PageAdminProjectCreate() {
  const trpcUtils = trpc.useUtils();
  const router = useRouter();

  const toastError = useToastError();
  const toastSuccess = useToastSuccess();

  const createProject = trpc.projects.create.useMutation({
    onSuccess: async () => {
      await trpcUtils.projects.getAll.invalidate();
      toastSuccess({
        title: "Project created with success",
      });
      router.back();
    },
    onError: (error) => {
      if (isErrorDatabaseConflict(error, "name")) {
        form.setErrors({ name: "Name already used" });
        return;
      }
      toastError({
        title: "Failed to create the project",
      });
    },
  });

  const form = useForm<ProjectFormFields>({
    onValidSubmit: (values) => {
      createProject.mutate(values);
    },
  });

  return (
    <Formiz connect={form} autoForm>
      <AdminLayoutPage containerMaxWidth="container.md" showNavBar={false}>
        <AdminLayoutPageTopBar
          leftActions={<AdminBackButton />}
          rightActions={
            <>
              <AdminCancelButton />
              <Button
                type="submit"
                variant="@primary"
                isLoading={createProject.isLoading || createProject.isSuccess}
                isDisabled={!form.isValid && form.isSubmitted}
              >
                Create
              </Button>
            </>
          }
        >
          <Heading size="sm">New Project</Heading>
        </AdminLayoutPageTopBar>
        <AdminLayoutPageContent>
          <ProjectForm />
        </AdminLayoutPageContent>
      </AdminLayoutPage>
    </Formiz>
  );
}
```

</Steps>

---

## Step 6: Allows to view a project

<Steps>
### Create the tRPC query
** Work in progress **
- create tRPC query

### Create the page

** Work in progress **

- create PageAdminProject in feature
- create "shell" page with AppLayoutPage

### Create the NextJS route

** Work in progress **

- create page.tsx in /src/app for routing with 'use client'

### Display the data

** Work in progress **

### Hanlde error state

** Work in progress **

</Steps>

---

## Step 7: Allows to update a project

<Steps>
### Create the tRPC mutation
** Work in progress **

### Create the page

** Work in progress **

- create PageAdminProjectUpdate in feature
- create "shell" page with AppLayoutPage

### Create the NextJS route

** Work in progress **

- create page.tsx in /src/app for routing with 'use client'

### Display the form

** Work in progress **

- use the ProjectForm component
- use getById query to fill the form

### Submit the form

- use tRPC mutation
- redirect to "view" url

### Hanlde errors

** Work in progress **

</Steps>

---

## Step 8: Allows to delete a project

<Steps>
### Create the tRPC mutation
** Work in progress **

### Use the tRPC mutation

** Work in progress **

### Add confirm modals

** Work in progress **

</Steps>

---

## Step 9: Add the translations

** Work in progress **

```

```
